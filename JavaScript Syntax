# Commenting in Javascript
- in line comment:
use //
ex) var number = 5; // in-line comment

- multi line comment:
/* this is a multi-line comment */
start and end /* */

# Data Types
- undefined, null, boolean, string, number, symbol, object
- variable (var / let / const)
var can be used through whole program, let is for only the scope, const is a variable that you should never change.
var myName = "Beau"
myName = 8

let ourName = "freeCodeCamp"

const pi = 3.14

# Storing values with the assignment operator
var a;  <- declaring operator
var b = 2;  <- declaring and assigning

a = 7;  <- already declared so this is just assigning.

console.log <- see things in console
console.log(a) <- 7

# Initializing Variables w/ Assignment Operator

# Incrementing Numbers
var a=2;
a++;          <- 3
a--;          <- 1

# Compound Assignment with Augmented Addition
a+=1;
a-=1;
a*=1;
a/=1;

# Declare String variables
var firstName = "Alan";

# Quote
var myStr= "I am a \"double quoted\" string inside \"double quotes\"";
console.log(myStr)
var myStr= 'I am a "double quoted" string inside "double quotes"';
var myStr= `'I am a "double quoted" string inside "double quotes"'`; <- back ticks make single and double both usable.

# Escape Sequences in Strings
\'  single quote
\"  double quote
\\  backslash
\n  newline
\r carriage return
\t tab
\b backspace
\f form feed

var myStr = "FirstLine\n\t\\\SecondLine\nThirdLine"

# Concatenating Strings with Plus Operator
var ourStr = "I come first. " + "I come second.";

# Concatenating Strings with Plus Equals Operator
var ourStr = "I come first. ";
ourStr += "I come second.";

# Constructing Strings with Variables
var ourName = "freeCodeCamp";
var ourStr = "Hello, our name is " + ourName + ", how are you?";

console.log(ourStr)

# Appending Variables to Strings
var anAdjective = "awesome!";
var ourStr = "freeCodeCamp is ";
ourStr += anAdjective;

# Find Length of String
var firstNameLength = 0;
var firstNAme = "Ada";

firstNameLength = firstName.length;

# Bracket Notation
var firstLetterOfFirstName = "";
var firstName = "Ada";
firstLetterOfFirstName = firstName[0];
console.log(firstLetterofFirstName)

# String Immutability
var myStr = "Jello World";
myStr[0] = "H";  <- We can't change individual letter but change the whole string
myStr = "Hello World";

# Bracket notation to find last letter
var firstName = "Ada";
var lastLetterOfFirstName = firstName[firstName.length - 1];
var lastName = "LoveLace"
var lastLetterOfLastName = lastName[lastName.length - 1];

# Word Blanks
function wordBlanks(myNoun, myAdjective, myVerb, myAdverb) {
  var result = "";
  result += "The " + myAdjective +" "+ myNoun +" "+ myVerb + " to the store " + myAdverb
  return result;
}
console.log(wordBlanks("dog", "big", "ran", "quickly"));

# Store Multiple Values with Arrays
var ourArray = ["John", 23];
var myArray = ["Quincy", 1];

# Nested Array
var ourArray = [["the Universe", 42], ["everything", 101010]];
var myArray = [["Bulls", 23], ["white sox", 45]];

# Access Array Data with Indexes
var ourArray = [50,60,70];
var ourData = ourArray[0];   <- 50

# Modify Array Data with Indexes
var ourArray = [18, 64, 99];
ourArray[1] = 45;           <- new array [18,45,99]

var myArray = [18, 64, 99];
myArray[0] = 45;
console.log(myArray)

# Access Multi Dimensional Arrays with Indexes
var myArray = [[1,2,3], [4,5,6], [7,8,9], [[10,11,12], 13, 14]];
var myData = myArray[0][0];    <- 1
console.log(myData)

# Manipulate Arrays with push()
var ourArray = ["Stimpson", "J", "cat"];
ourArray.push(["happy", "joy"]) <- new ourArray = ["Stimpson", "J", "cat", ["happy", "joy"]]
push function pushes the array into the ourArray in the end

# Manipulate Arrays with pop()
var ourArray = [1,2,3];
var removedFromOurArray = ourArray.pop() <- removedFromOurArray is 3 / ourArray is [1,2]

var myArray = [["John", 23], ["cat", 2]];
var removedFromMyArray = myArray.pop()
console.log(myArray)  <- ["John", 23]

# Manipulate Arrays with shift()
var ourArray = ["Stimpson", "J", ["cat"]];
var removedFromOurArray = ourArray.shift() <- removedFromOurArray is "Stimpson" / ourArray is ["J", ["cat"]]
shift removes the first array

# Manipulate Arrays with unshift()
var ourArray = ["Stimpson", "J", "cat"];
ourArray.shift();  <- ourArray equals ["J", "cat"]
ourArray.unshift("Happy"); <- ourArray now equals ["Happy", "J", "cat"]
unshift adds element to the beginning of array.

var myArray = [["John", 23], ["dog", 3]];
myArray.shift();
myArray.unshift(["Paul", 35]);  <- myArray now equals [["Paul", 35], ["dog", 3]]

# Shopping List (Nested Array)
var myList = [["cereal", 3], ["milk", 2], ["banana", 3], ["juice", 2], ["eggs", 5]]

# Write Reusable Code with Functions
function ourReusableFunction() {
  console.log("Heyya, World");        <- code between {} will be the main.
}

ourResuableFunction();   <- Heyya, World will come out.

function resuableFunction() {
  console.log("Hi World");
}

resuableFunction();    <- Hi World will come up.

# Passing Values to Functions with Arguments
function ourFunctionWithArgs(a, b) {
  console.log(a - b);
}
ourFunctionWithArgs(10, 5); <- output 5

function functionWithArgs(a, b) {
  console.log(a + b);
}
functionWithArgs(10, 5); <- output 15

# Global Scope and Functions
var myGlobal = 10;

function fun1() {
  oopsGlobal = 5;   <- no var keyword. with no var keyword, it becomes global automatically. with var, it's bound on the function.
}

function fun2() {
  var output = "";
  if (typeof myGlobal != "undefined") {
    output += "myGlobal: " + myGlobal;
  }
  if (typeof oopsGlobal != "undefined") {
    output += " oopsGlobal: " + oopsGlobal;
  }
  console.log(output);
}
fun1();
fun2();

# Local Scope and Functions
function myLocalScope() {
  var myVar = 5;              <- declared inside function
  console.log(myVar);
}
myLocalScope();

console.log(myVar);           <- Reference Error: myVar is not defined. myVar is a local scope

# Global vs Local Scope in Functions
var outerWear = "T-Shirt";

function myOutfit() {
  var outerWear = "sweater";
  return outerWear;
}

console.log(myOutfit());     <- result is sweater.
console.log(outerWear);      <- result is T-shirt

# Return a Value from a Function with Return
function minusSeven(num) {
  return num - 7;
}

console.log(minusSeven(10));      <- 3

function timesFive(num) {
  return num * 5;
}

console.log(timesFive(5));

# Understanding Undefined Value Returned from a Function
var sum = 0;
function addThree() {
  sum = sum + 3;
}

function addFive() {
  sum = sum + 5l
}

# Assignment with a returned value
var change = 0;

fuction change(num) {
  return (num + 5) / 3;
}

changed = change(10);

var processed = 0;

function processArg(num) {
  return (num + 3) / 5;
}

processed = processArg(7);

# Stand in Line (Queue)
function nextInLine(arr, item) {
  arr.push(item);       <- adds the item to the end.
  return arr.shift();   <- removes first item and returns the first item.
}

var testArr = [1,2,3,4,5];

console.log("Before: " + JSON.stringify(tesetArr)); <- JSON.stringify change and array into a string.
console.log(nextInLine(testArr, 6));
console.log("After: " + JSON.stringify(testArr));

# Boolean Values
function welcomeToBooleans() {
  return false;    <- or return true 
}

# Use Conditional Logic with If Statement
function ourTrueOrFalse(isItTrue) {
  if (isItTrue) {                <- () defines the condition
    return "Yes, it's true";
  }
  return "No, it's false";
}

function trueOrFalse(wasThatTrue) {
  if (wasThatTrue) {
    return "Yes, that was true";
  }
  return "No, that was false";

}

console.log(trueOrFalse(true));

# Comparison with the Equality Operator
function testEqual(val) {
  if (val == 12) {
    return "Equal";
  }
  return "Not Equal";
}

console.log(testEqual(10));

# Comparison with the Strict Equality Operator
3 === 3   <- true
3 === '3' <- false because the right 3 is a string and not a number.

function testEqual(val) {
  if (val === 7) {
    return "Equal";
  }
  return "Not Equal";
}

console.log(testStrict('7')); <- false because 7 is not '7'

# Practice Comparing different values
3 == '3' <- == performs a type conversion so it's true
3 === '3' <- false. No type conversion.

# Comparison with the inequality operator
function testNotEqual(val) {
  if (val != 99) {
    return "Not Equal;
  }
  return "Equal";
}

# Comparison with the Strict inequality operator
function testNotEqual(val) {
  if (val !== 99) {               <- !== does not convert types 
    return "Not Equal;
  }
  return "Equal";
}

# Comparison with logical and operator
function testLogicalAnd(val) {
  if (val <= 50) {
    if (val >= 25) {
      return "Yes";
    }
  }
  return "No";
}

function testLogicalAnd(val) {
  if (val <= 50 && val >= 25) {
    return "Yes";
  }
  return "No";
}

# Comparison with logical or operator
function testLogicalOr(val) {
  if (val <= 10 || val > 20) {
    return "Outside";
  }
  return "Inside";
}

# Else Statement
function testLogicalAnd(val) {
  if (val > 5) {
    result = "Bigger than 5";
  }
  if (val <= 5) {
    return "5 or Smaller";
  }

  return result;
}

function testLogicalAnd(val) {
  if (val > 5) {
    result = "Bigger than 5";
  } else {
    return "5 or Smaller";
  }

  return result;
}

# Else If Statments
function testElseIf(val) {
  if (val > 10) {
    return "Greater than 10";
  }
  if (val < 5) {
    return "Smaller than 5";
  }
  return "Between 5 and 10";
}
testElseIf(7);

function testElseIf(val) {
  if (val > 10) {
    return "Greater than 10";
  } else if (val < 5) {
    return "Smaller than 5";
  } else {
  return "Between 5 and 10";
  }
}
testElseIf(7);

# Logical Order in If Else Statements
function orderMyLogic(val) {
  if (val < 5) {
    return "Less than 5";
  } else if (val < 10) {
    return "Less than 10";
  } else {
    return "Greater than or equal to 10";
  }
}

console.log(orderMyLogic(7));

# Chaining If Else Statements
function testSize(num) {
  if (num < 5) {
    return "Tiny"
  } else if (num < 10) {
    return "Small"
  } else if (num < 15) {
    return "Medium"
  } else if (num < 20) {
    return "Large"
  } else {
    return "Huge"
  }
}

console.log(testSize(7));

# Golf Code
var names = ["Hole-in-one!", "Eagle", "Birdie", "Par", "Bogey", "Double Bogey", "Go Home"]
function golfScore(par, strokes) {
  if (strokes == 1) {
    return names[0]
  } else if (strokes <= par - 2) {
    return names[1]
  } else if (strokes == par - 1) {
    return names[2]
  } else if (strokes <= par) {
    return names[3]
  } else if (strokes <= par + 1) {
    return names[4]
  } else if (strokes <= par + 2) {
    return names[5]
  } else if (strokes <= par + 3) {
    return names[6]
  }
}

console.log(golfScore(5, 4));

# Switch Statements
function caseOnSwitch(val) {
  var answer = "";
  switch(val) {
    case 1:                <- if the case of val equals one(: is ===)
      answer = "alpha";
      break;                 <- end of the case statement and goes to te end
    case 2:
      answer = "beta";
      break;
    case 3:
      answer = "gamma";
      break;
    case 4:
      answer = "delta";
      break
  }
  return answer;
}

console.log(caseInSwitch(1));

# Default Option in Switch Statements
function switchOfStuff(val) {
    var answer = "":
    switch  (val) {
      case "a":
        answer = "apple";
        break;
      case "b":
        answer = "bird";
        break;
      case "c":
        answer = "cat";
        break;
      default:
        answer = "stuff";
        break;
} 
  return answer;
}

console.log(switchOfStuff("2"));  <- stuff

# Multiple Identical Options in Switch Statement
function sequentialSizes(val) {
  var answer = "";
  switch(val) {
    case 1:
    case 2:
    case 3:
      answer = "Low";
      break;
    case 4:
    case 5:
    case 6:
      answer = "Mid";
      break;
    case 7:
    case 8:
    case 9:
      answer = "High";
      break;
  }
  return answer;
}

console.log(sequestialSizes(1)); <- if case 1,2,3 Low, if case 4,5,6 Mid, 7,8,9 then High.

# Replacing If Else Chains with Switch
function chainToSwitch(val) {
  var answer = "";
  if (val === "bob") {
    answer = "Marley";
  } else if (val === 42) {
    answer = "The Answer";
  } else if (val === 1) {
    answer = "There is no #1";
  } else if (val === 99) {
    answer = "Missed me by this much!";
  } else if (val === 7) {
    answer = "Ate Nine";

  return answer;
}

function chainToSwitch(val) {
  var answer = "";
  switch(val) {
    case "bob":
      answer = "Marley";
      break;
    case 42:
      answer = "The Answer";
      break;
    case 1:
      answer = "There is no #1";
      break;
    case 99:
      answer = "Missed me by this much!";
      break;
    case 7:
      answer = "Ate Nine";
      break;
  }
    return answer;
}

# Returning Boolean values from Functions
function isLess(a, b) {
    if (a < b) {
      return true;
    } else {
      return false;
    }
}
console.log(isLess(10, 15));

function isLess(a, b) {
    return a < b;              <- executes same objective as above.
}
console.log(isLess(10, 15));

# Returning Early Pattern from Functions
function abTest(a,b) {
  if (a < 0 || b < 0) {
    return undefined;
  }
  return Math.round(Math.pow(Math.sqrt(a) + Math.sqrt(b), 2));
}

console.log(abTest(-2,2)); <- null or undefined.

# Counting Cards
var count = 0;
function cc(card) {
  switch(card) {
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      count++;
      break;
    case 10:
    case "J":
    case "Q":
    case "K":
    case "A":
      count--;
      break;
  }

  var holdbet = "Hold"
  if (count > 0) {
    holdbet = "Bet"
  }
  return count + " " + holdbet;

}

cc(2); cc(3); cc(7); cc('K'); cc('A');
console.log(cc(4))

# Build JavaScript Objects
var ourDog = {               <- objects access data with properties and not index.
  "name": "Camper",          <- everything before colon is properties. value is after colon.
  "legs": 4,
  "tails": 1,
  "friends": ["everything!"]
};
var myDog = {
  "name": "Quincy",
  "legs": 3,
  "tails": 2,
  "friends": []
};

# Accessing Object Properties with Dot Notation
var testObj = {
  "hat": "ballcap",
  "shirt": "jersey",
  "shoes": "cleats"
};

var hatValue = testObj.hat;  <- ballcap
var shirtValue = testObj.shirt;  <- jersey

# Accessing Object Properties with Bracket Notation
var testObj = {
  "an entree": "hamburger",
  "my side": "veggies",
  "the drink": "water"
};

var entreeValue = testObj["an entree"]; <- braket with double quotation
var drinkValue = testObj['the drink'];  <- braket with single quotation

# Accessing Object Properties with Variables
var testObj = {
  12: "Namath",
  16: "Montana",
  19: "Unitas"
};

var playerNumber = 16;
var player = testObj[playerNumber]; <- player is now Montana

# Updating Object Property
var ourDog = {
  "name": "Camper",
  "legs": 4,
  "tails": 1,
  "friends": ["everything!"]
};

ourDog.name = "Happy Camper"; <- camper changes to happy camper

var myDog = {
  "name": "Coder",
  "legs": 4,
  "tails": 1,
  "friends": ["freeCodeCamp Campers"]
};

myDog.name = "Happy Coder";

# Add New Properties to an Object
var ourDog = {
  "name": "Camper",
  "legs": 4,
  "tails": 1,
  "friends": ["everything!"]
};
ourDog.bark = "bow-wow";

var myDog = {
  "name": "Happy Coder",
  "legs": 4,
  "tails": 1,
  "friends": ["freeCodeCamp Campers"]
};
myDog['bark'] = "woof!"

# Delete Properties From an Object
var ourDog = {
  "name": "Camper",
  "legs": 4,
  "tails": 1,
  "friends": ["everything!"]
  "bark": "bow-wow"
};

delete ourDog.bark;

var myDog = {
  "name": "Happy Coder",
  "legs": 4,
  "tails": 1,
  "friends": ["freeCodeCamp Campers"]
  "bark": "woof"
};

delete myDog.tails;

# Using Objects for Lookups
function phoneticLookup(va) {
  var result = "";
  switch(val) {
    case "alpha":
      result = "Adams";
      break;
    case "bravo":
      result = "Boston";
      break;
    case "charlie";
      result = "Chicago";
      break;
    case "delta":
      result = "Denver";
      break;
    case "echo":
      result = "Easy";
      break;
    case "foxtrot":
      result = "Frank";
}

function phoneticLookup(va) {   <- using lookup instead of switch
  var result = "";
  var lookup = {
    "alpha": "Adams",
    "bravo": "Boston",
    "charlie": "Chicago",
    "delta": "Denver",
    "echo": "Easy",
    "foxtrot": "frank"
  };
  result = lookup[val]
  return result;
}

cosole.log(phoneticLookup("charlie")); <- Chicago

# Testing Objects for Properties
var myObj = {
  gift: "pony",
  pet: "kitten",
  bed: "sleigh"
}

function checkObj(checkProp) {
  if (myObj.hasOwnProperty(checkProp)) {       <- obj.hasOwnProperty(checkProp) checks if it has own property of the checkProp in the object.
    return myObj[checkProp]                       the method just exists.
  }  else {
    return "Not Found"
  }
}

console.log(checkObj("gift"));                <- return pony.

# Manipulating Complex Objects
var myMusic = [                              <- array
  {                                          <- object
    "artist": "Billy Joel",
    "title": "Piano Man",
    "release_year": 1973,
    "formats": [
      "CD",
      "8T",
      "LP",
    ],
    "gold": true
  },
  {
    "artist": "Beau Carnes",
    "title": "Cereal Man",
    "release_year": 2003,
    "formats": [
      "YouTube Video"                       <- key value pair and this type of complex objects is similar to JSON
  }
];

# Accessing Nested Objects
var myStorage = {
  "car": {
    "inside": {
      "glove box": "maps",
      "passenger seat": "crumbs",
      },
    "outside": {
      "trunk": "jack"
    }
  }
};

var gloveBoxContents = myStorage.car.inside["glove box"];

console.log(globeBoxContents)               <- maps

# Accessing Nested Arrays
var myPlants = [
  {
    type: "flowers",
    list: [                       <- first object
      "rose",
      "tulip",
      "dandelion",
    ]
  },
  {
    type: "trees",
    list: [
      "fir",                     <- second object
      "pine",
      "birch"
    ]
  }
];

var secondTree = myPlants[1].list[1];              <- pine

# Record Collection
var collection = {
    "2548": {
      "album": "Slippery When Wet",
      "artist": "Bon Jovi",
      "tracks": [
        "Let It Rock",
        "You Give Love a Bad Name"
      ]
    },
    "2408": {
      "album": "1999",
      "artist": "Prince",
      "tracks": [
        "1999",
        "Little Red Corvette",
      ]
    },
    "1245": {
      "artist": "Robert Palmer",
      "tracks": []
    },
    "5439": {
      "album": "ABBA Gold"
    }
};

var collectionCopy = JSON.parse(JSON.stringify(collection));         <- make copy of object.

function updateRecords(id, prop, value) {
  if (value === "") {
    delete collection[id][prop];
  } else if (prop === "tracks") {
    collection[id][prop] = collection[id][prop] || [];               <- collection id prop exist, we will set it as is but if not will be blank
    collection[id][prop].push(value);
  } else  {
    collection[id][prop] = value;
  }
  return collection;
}

console.log(updateRecords(5439, "artist", "ABBA"));       <- 5439: {album:"ABBA Bold", artist:"ABBA"}

# Iterate with While Loop
var myArray = [];
var i = 0;
while(i < 5) {
  myArray.push(i);
  i++;
}

console.log(myArray); <- [0,1,2,3,4]

# Iterate with For Loop
var ourArray = [];
for (var i = 0; i < 5; i++) {          <- initialize variable; condition for executing code block; what to do after code block
  ourArray.push(i);
}

var myArray = [];
for (var i = 1; i < 6; i ++) {
  myArray.push(i);
}

console.log(myArray);        <- [1,2,3,4,5]

# Iterate Odd Numbers with a For Loop
var ourArray = [];
for (var i = 0; i < 10; i+=2) {          <- initialize variable; condition for executing the code block; what to do after code block
  ourArray.push(i);
}
console.log(ourArray);                  <- [0,2,4,6,8]

var myArray = [];
for (var i = 1; i < 10; i +=2) {
  myArray.push(i);
}

console.log(myArray);                   <- [1,3,5,7,9]

# Count Backwards with a For Loop
var ourArray = [];
for (var i = 10; i > 0; i -= 2) {
  ourArray.push(i);
}
console.log(ourArray);          <- [10,8,6,4,2]

var myArray = [];
for (var i = 9; i > 0; i -=2){
  myArray.push(i);
}
console.log(myArray);            <- [9,7,5,3,1]

# Iterate through an Array with a For Loop
var ourArr = [9,10,11,12];
var ourTotal = 0;
for (var i=0; i < ourArr.length; i++) {
  ourTotal += ourArr[i];
}
console.log(ourTotal);            <- 42

var myArr = [2,3,4,5,6];
var total = 0;
for (var i=0; i < myArr.length; i++) {
  total += myArr[i];
}
console.log(total);               <- 20

# Nesting For Loop
function multiplyAll(arr) {
  var product = 1;
  for (var i = 0; i < arr.length; i++) {
    for (var j = 0; j < arr[i].length; j++) {
      product *= arr[i][j];
    }
  }
  return product;
}

var product = multiplyAll([[1,2], [3,4], [5,6,7]]);
console.log(product);            <- 5040

# Iterate with Do... While Loop
var myArray = [];
var i = 10;

while (i < 5) {            <- This is a while loop. But a do while loop will do something and then go loop.
  myArray.push(i);
  i++;
}

do {                       <- This is a do while loop. do will do something at least once.
  myArray.push(i);
  i++;
} while (i < 5)

console.log(i, myArray);  <- 11, [10]

# Profile Lookup Coding Challenge
//Setup
var contacts = [
    {
        "firstName": "Akira",
        "lastName": "Laine",
        "number": "0543236543",
        "likes": ["Pizza", "Coding", "Brownie Points"]
    },
    {
        "firstName": "Harry",
        "lastName": "Potter",
        "number": "0994372684",
        "likes": ["Hogwarts", "Magic", "Hagrid"]
    },
    {
        "firstName": "Sherlock",
        "lastName": "Holmes",
        "number": "0487345643",
        "likes": ["Intriguing Cases", "Violin"]
    },
    {
        "firstName": "Kristian",
        "lastName": "Vos",
        "number": "unknown",
        "likes": ["Javascript", "Gaming", "Foxes"]
    }
];

function lookUpProfile(firstName, prop) {
  for (var i = 0; i < contacts.length; i++) {
    if(contacts[i].firstName === name) {
      return contacts[i][prop] || "No such property"        <- use contacts[i][prop] if exist, otherwise use No such Property
    }
  }
  return "No such contact";
}

// Change these values to test your function
lookUpProfile("Akira", "likes");
console.log(data);                              <- ["Pizza", "Coding", Brownie Points"]

# Generate Random Fractions
function randomFraction() {

  return Math.random();                   <- Math.random function
}

console.log(randomFraction());   <- 0.23813741879825767

# Generate Random While Numbers
var randomNumberBetween0and19 = Math.floor(Math.random() * 20);    <- round down with Math.floor

function randomWholeNum()
  return Math.floor(Math.random() * 10);
}
console.log(randomWholeNum());

# Generate Random Whole Numbers within a Range
function ourRandomRange(ourMin, ourMax) {
  return Math.floor(Math.random() * (ourMax - ourMin + 1)) + ourMin;
}

ourRandomRange(1, 9);

function randomRange(myMin, myMax) {
  return Math.floor(Math.random() * (myMax - myMin + 1)) + myMin;
}
var myRandom = randomRange(5, 15);

console.log(myRandom);

# Use the parseInt Function
function convertToInteger(str) {
  return parseInt(str);            <- convert str into an integer with partseInt
}

convertToInteger("56");            <- return as 56 not "56"

# Use the parseInt Function with a Radix
function convertToInteger(str) {
  return parseInt(str, 2)                                                <- Radix specifies the base of the number in a string
}

convertToInteger("10011");                                               <- computer knows that this is a binary number

# Use the Conditional (Ternary) Operator
// condition ? statement-if-true : statement-if-false;

function checkEqual(a,b) {
  if(a === b) {
    return true;                       <- using if else statement instead of Ternary Operator
  }
  else {
    return false;
  }
}

checkEqual(1, 2);

function checkEqual(a,b) {
  return a === b ? true : false;        <- This is using Ternary Operator
}

checkEqual(1, 2);

function checkEqual(a,b) {
  return a === b ;                      <- This is not using Ternary Operator but gives the same result
}

checkEqual(1, 2);

# Use Multiple Conditional (Ternary) Operators
function checkSign(num) P
  return num > 0 ? "positive" : num < 0 ? "negative" : "zero"       <- if num is bigger than 0, the Ternary Operator(?) comes, "positive" if true,
}                                                                      if negative another conditional num < 0 kicks in and have Ternary Operator.

console.log(checkSign(10));

# Differences Between the var and let keywords
var catName = "Quincy";
var quote;

var cateName = "Beau";

function catTalk() {
  "use strict";

  catName = "Oliver";
  quote = catName + " says Meow!";

}
catTalk();

let catName = "Quincy";
let quote;

catName = "Beau";        <- let catName = "Beau" will create an error because you're declaring catName twice.
                            But catName = "Beau" will not be an error because it is not declaring but just setting the same variable to "Beau"

# Compare Scopes of var and let keywords
function checkScope() {
"use strict";
  let i = "function scope";
  if (true) {
    let i = "block scope";                     <- let has a scope. if it's var, var is a global scope.
    console.log("Block scope i is: ", i);
  }
  console.log("Function scope i is: ", i);
  return i;
}

checkScope();

Block scope i is "block scope"
Function scope i is: "function scope"

function checkScope() {
"use strict";
  //let i = "function scope";
  if (true) {
    var i = "block scope";                     <- var results in both block scope because it's global. but let will be block scope & error
    console.log("Block scope i is: ", i);         Why error? because i is not defined.
  }
  console.log("Function scope i is: ", i);
  return i;
}

checkScope();

Block scope i is "block scope"
Function scope i is: "block scope"

# Declare a Read-Only Variable with the const Keyword
function printManyTimes(str) {
  "use strict";

  var sentence = str + " is cool!";
  sentence = str + " is amazing!"
  for(var i = 0l i < str.length; i +=2) {
    console.log(sentence);
  }

}
printManyTimes("freeCodeCamp");             <- freeCodeCamp is amazing!

function printManyTimes(str) {
  "use strict";

  const SENTENCE = str + " is cool!";          <- const makes it read only so you can't reassign the variable. If you never want to reassign variable use const.
  sentence = str + " is amazing!"                 for const variables, name it in ALL CAPS. 
  for(let i = 0l i < str.length; i +=2) {      <- Also, mainly use const with let and not var.
    console.log(sentence);
  }

}
printManyTimes("freeCodeCamp");     <- Error: SyntaxError: unkown: "sentence" is read-only(/index.js:1)

# Mutate and Array Declared with const
const s = [5, 7, 2];                 <- While you cannot declare variable with const, you can mutate an array.
function editInPlace() {
  "use strict";
  s = [2, 5, 7];

}
editInPlace();                       <- error S is read only.

const s = [5, 7, 2];                 
function editInPlace() {
  "use strict";
  //s = [2, 5, 7];
  s[0] = 2;                          <- with index array you can reassign the const array components.
  s[1] = 5;
  s[2] = 7;
}
editInPlace();
console.log(s)                       <- [2, 5, 7]

# Prevent Object Mutation
function freezeObj() {              There is a obj.freeze that prevents object mutation
  "use strict";
  const MATH_CONSTANTS = {          <- create const as an object. This can stil be changed
    PI: 3.14
  };

  try {                             <- this is a try catch block and it's going to try what's in the first part of the block
    MATH_CONSTANTS.PI = 99;            If there's an error it's going to go into the catch part and it's going to log it out.
  } catch( ex ) {                      try changing match constants to 99.
    console.log(ex);
  }
  return MATH_CONSTANTS.PI;
}

const PI = freezeObj();           
console.log(PI);                    <- 99


function freezeObj() {              There is a obj.freeze that prevents object mutation
  "use strict";
  const MATH_CONSTANTS = {
    PI: 3.14
  };

Object.freeze(MATH_CONSTANTS);     <- THIS freezes MATH_CONSTANTS and when you try to change it, it gives out an error.

  try {                            
    MATH_CONSTANTS.PI = 99;        <- This part will not work and give out an error
  } catch( ex ) {                  <- This catch part will catch the exception
    console.log(ex);               <- This will log out the exception
  }
  return MATH_CONSTANTS.PI;
}

const PI = freezeObj();           
console.log(PI);                    <- TypeError: Cannot assign to read only property 'PI' of object '#<Object>' (/index.js:13)

# Use Arrow Functions to Write Concise Anonymous Functions
var magic = function() {      <- This function is called an anonymous function. It doesn't have a name. It is assigned to a variable though.
  return new Date();             When you have an anonymous function, you can convert it to an arrow function which makes it a little quicker to write.
};

var magic = () => {           <- This is the same thing as above.
  return new Date();
};

var magic = () => new Date(); <- Same as above. No need to have { return }

const magic = () => new Date(); <- just changed var to const

# Write Arrow Functions with Parameters
var myConcat = function(arr1, arr2) {         <- This is normal function with parameters
  return  arr1.concat(arr2);
};

console.log(myConcat([1, 2], [3, 4, 5]));


var myConcat = (arr1, arr2) => arr1.concat(arr2);   <- This is with Array function

console.log(myConcat([1, 2], [3, 4, 5]));         <- [1, 2, 3, 4, 5]

# Write Higher Order Arrow Functions
const realNumberArray = [4, 5.6, -9.8, 3.14, 42, 6, 8.34, -2];    <- array functions work well with higher order functions such as map, filter, reduce
                                                                     map, filter, reduce take functions as arguments for processing collections of data.
const squareList = (arr) => {                                        whenever one function takes another function as an argument it's good to use arrow function.
  const squaredIntegers = arr;
  return squaredIntegers;
};

const squaredIntegers = squareList(realNumberArray);
console.log(squaredIntegers);


const realNumberArray = [4, 5.6, -9.8, 3.14, 42, 6, 8.34, -2];

const squareList = (arr) => {                                      
  const squaredIntegers = arr.filter(num => Number.isInteger(num) && num > 0).map(x => x * x);  <- if you have only have single argument, you don't need parenthesis for the argument.
  return squaredIntegers;                                                                          filter command will filter to numbers more than zero and only an integer
};                                                                                                 x means every element in the array.

const squaredIntegers = squareList(realNumberArray);
console.log(squaredIntegers);                                    <- [16, 1764, 36]

# Default Parameters
const increment = (function() {
  return function increment(number, value) {
    return number + value;
  };
})();
console.log(increment(5, 2));
console.log(increment(5));
