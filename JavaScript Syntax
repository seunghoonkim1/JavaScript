# Commenting in Javascript
- in line comment:
use //
ex) var number = 5; // in-line comment

- multi line comment:
/* this is a multi-line comment */
start and end /* */

# Data Types
- undefined, null, boolean, string, number, symbol, object
- variable (var / let / const)
var can be used through whole program, let is for only the scope, const is a variable that you should never change.
var myName = "Beau"
myName = 8

let ourName = "freeCodeCamp"

const pi = 3.14

# Storing values with the assignment operator
var a;  <- declaring operator
var b = 2;  <- declaring and assigning

a = 7;  <- already declared so this is just assigning.

console.log <- see things in console
console.log(a) <- 7

# Initializing Variables w/ Assignment Operator

# Incrementing Numbers
var a=2;
a++;          <- 3
a--;          <- 1

# Compound Assignment with Augmented Addition
a+=1;
a-=1;
a*=1;
a/=1;

# Declare String variables
var firstName = "Alan";

# Quote
var myStr= "I am a \"double quoted\" string inside \"double quotes\"";
console.log(myStr)
var myStr= 'I am a "double quoted" string inside "double quotes"';
var myStr= `'I am a "double quoted" string inside "double quotes"'`; <- back ticks make single and double both usable.

# Escape Sequences in Strings
\'  single quote
\"  double quote
\\  backslash
\n  newline
\r carriage return
\t tab
\b backspace
\f form feed

var myStr = "FirstLine\n\t\\\SecondLine\nThirdLine"

# Concatenating Strings with Plus Operator
var ourStr = "I come first. " + "I come second.";

# Concatenating Strings with Plus Equals Operator
var ourStr = "I come first. ";
ourStr += "I come second.";

# Constructing Strings with Variables
var ourName = "freeCodeCamp";
var ourStr = "Hello, our name is " + ourName + ", how are you?";

console.log(ourStr)

# Appending Variables to Strings
var anAdjective = "awesome!";
var ourStr = "freeCodeCamp is ";
ourStr += anAdjective;

# Find Length of String
var firstNameLength = 0;
var firstNAme = "Ada";

firstNameLength = firstName.length;

# Bracket Notation
var firstLetterOfFirstName = "";
var firstName = "Ada";
firstLetterOfFirstName = firstName[0];
console.log(firstLetterofFirstName)

# String Immutability
var myStr = "Jello World";
myStr[0] = "H";  <- We can't change individual letter but change the whole string
myStr = "Hello World";

# Bracket notation to find last letter
var firstName = "Ada";
var lastLetterOfFirstName = firstName[firstName.length - 1];
var lastName = "LoveLace"
var lastLetterOfLastName = lastName[lastName.length - 1];

# Word Blanks
function wordBlanks(myNoun, myAdjective, myVerb, myAdverb) {
  var result = "";
  result += "The " + myAdjective +" "+ myNoun +" "+ myVerb + " to the store " + myAdverb
  return result;
}
console.log(wordBlanks("dog", "big", "ran", "quickly"));

# Store Multiple Values with Arrays
var ourArray = ["John", 23];
var myArray = ["Quincy", 1];

# Nested Array
var ourArray = [["the Universe", 42], ["everything", 101010]];
var myArray = [["Bulls", 23], ["white sox", 45]];

# Access Array Data with Indexes
var ourArray = [50,60,70];
var ourData = ourArray[0];   <- 50

# Modify Array Data with Indexes
var ourArray = [18, 64, 99];
ourArray[1] = 45;           <- new array [18,45,99]

var myArray = [18, 64, 99];
myArray[0] = 45;
console.log(myArray)

# Access Multi Dimensional Arrays with Indexes
var myArray = [[1,2,3], [4,5,6], [7,8,9], [[10,11,12], 13, 14]];
var myData = myArray[0][0];    <- 1
console.log(myData)

# Manipulate Arrays with push()
var ourArray = ["Stimpson", "J", "cat"];
ourArray.push(["happy", "joy"]) <- new ourArray = ["Stimpson", "J", "cat", ["happy", "joy"]]
push function pushes the array into the ourArray in the end

# Manipulate Arrays with pop()
var ourArray = [1,2,3];
var removedFromOurArray = ourArray.pop() <- removedFromOurArray is 3 / ourArray is [1,2]

var myArray = [["John", 23], ["cat", 2]];
var removedFromMyArray = myArray.pop()
console.log(myArray)  <- ["John", 23]

# Manipulate Arrays with shift()
var ourArray = ["Stimpson", "J", ["cat"]];
var removedFromOurArray = ourArray.shift() <- removedFromOurArray is "Stimpson" / ourArray is ["J", ["cat"]]
shift removes the first array

# Manipulate Arrays with unshift()
var ourArray = ["Stimpson", "J", "cat"];
ourArray.shift();  <- ourArray equals ["J", "cat"]
ourArray.unshift("Happy"); <- ourArray now equals ["Happy", "J", "cat"]
unshift adds element to the beginning of array.

var myArray = [["John", 23], ["dog", 3]];
myArray.shift();
myArray.unshift(["Paul", 35]);  <- myArray now equals [["Paul", 35], ["dog", 3]]

# Shopping List (Nested Array)
var myList = [["cereal", 3], ["milk", 2], ["banana", 3], ["juice", 2], ["eggs", 5]]

# Write Reusable Code with Functions
function ourReusableFunction() {
  console.log("Heyya, World");        <- code between {} will be the main.
}

ourResuableFunction();   <- Heyya, World will come out.

function resuableFunction() {
  console.log("Hi World");
}

resuableFunction();    <- Hi World will come up.

# Passing Values to Functions with Arguments
function ourFunctionWithArgs(a, b) {
  console.log(a - b);
}
ourFunctionWithArgs(10, 5); <- output 5

function functionWithArgs(a, b) {
  console.log(a + b);
}
functionWithArgs(10, 5); <- output 15

# Global Scope and Functions
var myGlobal = 10;

function fun1() {
  oopsGlobal = 5;   <- no var keyword. with no var keyword, it becomes global automatically. with var, it's bound on the function.
}

function fun2() {
  var output = "";
  if (typeof myGlobal != "undefined") {
    output += "myGlobal: " + myGlobal;
  }
  if (typeof oopsGlobal != "undefined") {
    output += " oopsGlobal: " + oopsGlobal;
  }
  console.log(output);
}
fun1();
fun2();

# Local Scope and Functions
function myLocalScope() {
  var myVar = 5;              <- declared inside function
  console.log(myVar);
}
myLocalScope();

console.log(myVar);           <- Reference Error: myVar is not defined. myVar is a local scope

# Global vs Local Scope in Functions
var outerWear = "T-Shirt";

function myOutfit() {
  var outerWear = "sweater";
  return outerWear;
}

console.log(myOutfit());     <- result is sweater.
console.log(outerWear);      <- result is T-shirt

# Return a Value from a Function with Return
function minusSeven(num) {
  return num - 7;
}

console.log(minusSeven(10));      <- 3

function timesFive(num) {
  return num * 5;
}

console.log(timesFive(5));

# Understanding Undefined Value Returned from a Function
var sum = 0;
function addThree() {
  sum = sum + 3;
}

function addFive() {
  sum = sum + 5l
}

# Assignment with a returned value
var change = 0;

fuction change(num) {
  return (num + 5) / 3;
}

changed = change(10);

var processed = 0;

function processArg(num) {
  return (num + 3) / 5;
}

processed = processArg(7);

# Stand in Line (Queue)
function nextInLine(arr, item) {
  arr.push(item);       <- adds the item to the end.
  return arr.shift();   <- removes first item and returns the first item.
}

var testArr = [1,2,3,4,5];

console.log("Before: " + JSON.stringify(tesetArr)); <- JSON.stringify change and array into a string.
console.log(nextInLine(testArr, 6));
console.log("After: " + JSON.stringify(testArr));

# Boolean Values
function welcomeToBooleans() {
  return false;    <- or return true 
}

# Use Conditional Logic with If Statement
function ourTrueOrFalse(isItTrue) {
  if (isItTrue) {                <- () defines the condition
    return "Yes, it's true";
  }
  return "No, it's false";
}

function trueOrFalse(wasThatTrue) {
  if (wasThatTrue) {
    return "Yes, that was true";
  }
  return "No, that was false";

}

console.log(trueOrFalse(true));

# Comparison with the Equality Operator
function testEqual(val) {
  if (val == 12) {
    return "Equal";
  }
  return "Not Equal";
}

console.log(testEqual(10));

# Comparison with the Strict Equality Operator
3 === 3   <- true
3 === '3' <- false because the right 3 is a string and not a number.

function testEqual(val) {
  if (val === 7) {
    return "Equal";
  }
  return "Not Equal";
}

console.log(testStrict('7')); <- false because 7 is not '7'

# Practice Comparing different values
3 == '3' <- == performs a type conversion so it's true
3 === '3' <- false. No type conversion.

# Comparison with the inequality operator
function testNotEqual(val) {
  if (val != 99) {
    return "Not Equal;
  }
  return "Equal";
}

# Comparison with the Strict inequality operator
function testNotEqual(val) {
  if (val !== 99) {               <- !== does not convert types 
    return "Not Equal;
  }
  return "Equal";
}

# Comparison with logical and operator
function testLogicalAnd(val) {
  if (val <= 50) {
    if (val >= 25) {
      return "Yes";
    }
  }
  return "No";
}

function testLogicalAnd(val) {
  if (val <= 50 && val >= 25) {
    return "Yes";
  }
  return "No";
}

# Comparison with logical or operator
function testLogicalOr(val) {
  if (val <= 10 || val > 20) {
    return "Outside";
  }
  return "Inside";
}

# Else Statement
function testLogicalAnd(val) {
  if (val > 5) {
    result = "Bigger than 5";
  }
  if (val <= 5) {
    return "5 or Smaller";
  }

  return result;
}

function testLogicalAnd(val) {
  if (val > 5) {
    result = "Bigger than 5";
  } else {
    return "5 or Smaller";
  }

  return result;
}

# Else If Statments
function testElseIf(val) {
  if (val > 10) {
    return "Greater than 10";
  }
  if (val < 5) {
    return "Smaller than 5";
  }
  return "Between 5 and 10";
}
testElseIf(7);

function testElseIf(val) {
  if (val > 10) {
    return "Greater than 10";
  } else if (val < 5) {
    return "Smaller than 5";
  } else {
  return "Between 5 and 10";
  }
}
testElseIf(7);

# Logical Order in If Else Statements
function orderMyLogic(val) {
  if (val < 5) {
    return "Less than 5";
  } else if (val < 10) {
    return "Less than 10";
  } else {
    return "Greater than or equal to 10";
  }
}

console.log(orderMyLogic(7));

# Chaining If Else Statements
function testSize(num) {
  if (num < 5) {
    return "Tiny"
  } else if (num < 10) {
    return "Small"
  } else if (num < 15) {
    return "Medium"
  } else if (num < 20) {
    return "Large"
  } else {
    return "Huge"
  }
}

console.log(testSize(7));

# Golf Code
var names = ["Hole-in-one!", "Eagle", "Birdie", "Par", "Bogey", "Double Bogey", "Go Home"]
function golfScore(par, strokes) {
  if (strokes == 1) {
    return names[0]
  } else if (strokes <= par - 2) {
    return names[1]
  } else if (strokes == par - 1) {
    return names[2]
  } else if (strokes <= par) {
    return names[3]
  } else if (strokes <= par + 1) {
    return names[4]
  } else if (strokes <= par + 2) {
    return names[5]
  } else if (strokes <= par + 3) {
    return names[6]
  }
}

console.log(golfScore(5, 4));

# Switch Statements
function caseOnSwitch(val) {
  var answer = "";
  switch(val) {
    case 1:                <- if the case of val equals one(: is ===)
      answer = "alpha";
      break;                 <- end of the case statement and goes to te end
    case 2:
      answer = "beta";
      break;
    case 3:
      answer = "gamma";
      break;
    case 4:
      answer = "delta";
      break
  }
  return answer;
}

console.log(caseInSwitch(1));

# Default Option in Switch Statements
function switchOfStuff(val) {
    var answer = "":
    switch  (val) {
      case "a":
        answer = "apple";
        break;
      case "b":
        answer = "bird";
        break;
      case "c":
        answer = "cat";
        break;
      default:
        answer = "stuff";
        break;
} 
  return answer;
}

console.log(switchOfStuff("2"));  <- stuff

# Multiple Identical Options in Switch Statement
function sequentialSizes(val) {
  var answer = "";
  switch(val) {
    case 1:
    case 2:
    case 3:
      answer = "Low";
      break;
    case 4:
    case 5:
    case 6:
      answer = "Mid";
      break;
    case 7:
    case 8:
    case 9:
      answer = "High";
      break;
  }
  return answer;
}

console.log(sequestialSizes(1)); <- if case 1,2,3 Low, if case 4,5,6 Mid, 7,8,9 then High.

# Replacing If Else Chains with Switch
function chainToSwitch(val) {
  var answer = "";
  if (val === "bob") {
    answer = "Marley";
  } else if (val === 42) {
    answer = "The Answer";
  } else if (val === 1) {
    answer = "There is no #1";
  } else if (val === 99) {
    answer = "Missed me by this much!";
  } else if (val === 7) {
    answer = "Ate Nine";

  return answer;
}

function chainToSwitch(val) {
  var answer = "";
  switch(val) {
    case "bob":
      answer = "Marley";
      break;
    case 42:
      answer = "The Answer";
      break;
    case 1:
      answer = "There is no #1";
      break;
    case 99:
      answer = "Missed me by this much!";
      break;
    case 7:
      answer = "Ate Nine";
      break;
  }
    return answer;
}

# Returning Boolean values from Functions
function isLess(a, b) {
    if (a < b) {
      return true;
    } else {
      return false;
    }
}
console.log(isLess(10, 15));

function isLess(a, b) {
    return a < b;              <- executes same objective as above.
}
console.log(isLess(10, 15));

# Returning Early Pattern from Functions
function abTest(a,b) {
  if (a < 0 || b < 0) {
    return undefined;
  }
  return Math.round(Math.pow(Math.sqrt(a) + Math.sqrt(b), 2));
}

console.log(abTest(-2,2)); <- null or undefined.

# Counting Cards
var count = 0;
function cc(card) {
  switch(card) {
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      count++;
      break;
    case 10:
    case "J":
    case "Q":
    case "K":
    case "A":
      count--;
      break;
  }

  var holdbet = "Hold"
  if (count > 0) {
    holdbet = "Bet"
  }
  return count + " " + holdbet;

}

cc(2); cc(3); cc(7); cc('K'); cc('A');
console.log(cc(4))

# Build JavaScript Objects
var ourDog = {               <- objects access data with properties and not index.
  "name": "Camper",          <- everything before colon is properties. value is after colon.
  "legs": 4,
  "tails": 1,
  "friends": ["everything!"]
};
var myDog = {
  "name": "Quincy",
  "legs": 3,
  "tails": 2,
  "friends": []
};

# Accessing Object Properties with Dot Notation
var testObj = {
  "hat": "ballcap",
  "shirt": "jersey",
  "shoes": "cleats"
};

var hatValue = testObj.hat;  <- ballcap
var shirtValue = testObj.shirt;  <- jersey

# Accessing Object Properties with Bracket Notation
var testObj = {
  "an entree": "hamburger",
  "my side": "veggies",
  "the drink": "water"
};

var entreeValue = testObj["an entree"]; <- braket with double quotation
var drinkValue = testObj['the drink'];  <- braket with single quotation

# Accessing Object Properties with Variables
var testObj = {
  12: "Namath",
  16: "Montana",
  19: "Unitas"
};

var playerNumber = 16;
var player = testObj[playerNumber]; <- player is now Montana

# Updating Object Property
var ourDog = {
  "name": "Camper",
  "legs": 4,
  "tails": 1,
  "friends": ["everything!"]
};

ourDog.name = "Happy Camper"; <- camper changes to happy camper

var myDog = {
  "name": "Coder",
  "legs": 4,
  "tails": 1,
  "friends": ["freeCodeCamp Campers"]
};

myDog.name = "Happy Coder";

# Add New Properties to an Object
var ourDog = {
  "name": "Camper",
  "legs": 4,
  "tails": 1,
  "friends": ["everything!"]
};
ourDog.bark = "bow-wow";

var myDog = {
  "name": "Happy Coder",
  "legs": 4,
  "tails": 1,
  "friends": ["freeCodeCamp Campers"]
};
myDog['bark'] = "woof!"

# Delete Properties From an Object
var ourDog = {
  "name": "Camper",
  "legs": 4,
  "tails": 1,
  "friends": ["everything!"]
  "bark": "bow-wow"
};

delete ourDog.bark;

var myDog = {
  "name": "Happy Coder",
  "legs": 4,
  "tails": 1,
  "friends": ["freeCodeCamp Campers"]
  "bark": "woof"
};

delete myDog.tails;

# Using Objects for Lookups
function phoneticLookup(va) {
  var result = "";
  switch(val) {
    case "alpha":
      result = "Adams";
      break;
    case "bravo":
      result = "Boston";
      break;
    case "charlie";
      result = "Chicago";
      break;
    case "delta":
      result = "Denver";
      break;
    case "echo":
      result = "Easy";
      break;
    case "foxtrot":
      result = "Frank";
}

function phoneticLookup(va) {   <- using lookup instead of switch
  var result = "";
  var lookup = {
    "alpha": "Adams",
    "bravo": "Boston",
    "charlie": "Chicago",
    "delta": "Denver",
    "echo": "Easy",
    "foxtrot": "frank"
  };
  result = lookup[val]
  return result;
}

cosole.log(phoneticLookup("charlie")); <- Chicago

# Testing Objects for Properties
var myObj = {
  gift: "pony",
  pet: "kitten",
  bed: "sleigh"
}

function checkObj(checkProp) {
  if (myObj.hasOwnProperty(checkProp)) {       <- obj.hasOwnProperty(checkProp) checks if it has own property of the checkProp in the object.
    return myObj[checkProp]                       the method just exists.
  }  else {
    return "Not Found"
  }
}

console.log(checkObj("gift"));                <- return pony.

# Manipulating Complex Objects
var myMusic = [                              <- array
  {                                          <- object
    "artist": "Billy Joel",
    "title": "Piano Man",
    "release_year": 1973,
    "formats": [
      "CD",
      "8T",
      "LP",
    ],
    "gold": true
  },
  {
    "artist": "Beau Carnes",
    "title": "Cereal Man",
    "release_year": 2003,
    "formats": [
      "YouTube Video"                       <- key value pair and this type of complex objects is similar to JSON
  }
];

# Accessing Nested Objects
var myStorage = {
  "car": {
    "inside": {
      "glove box": "maps",
      "passenger seat": "crumbs",
      },
    "outside": {
      "trunk": "jack"
    }
  }
};

var gloveBoxContents = myStorage.car.inside["glove box"];

console.log(globeBoxContents)               <- maps

# Accessing Nested Arrays
var myPlants = [
  {
    type: "flowers",
    list: [                       <- first object
      "rose",
      "tulip",
      "dandelion",
    ]
  },
  {
    type: "trees",
    list: [
      "fir",                     <- second object
      "pine",
      "birch"
    ]
  }
];

var secondTree = myPlants[1].list[1];              <- pine

# Record Collection
var collection = {
    "2548": {
      "album": "Slippery When Wet",
      "artist": "Bon Jovi",
      "tracks": [
        "Let It Rock",
        "You Give Love a Bad Name"
      ]
    },
    "2408": {
      "album": "1999",
      "artist": "Prince",
      "tracks": [
        "1999",
        "Little Red Corvette",
      ]
    },
    "1245": {
      "artist": "Robert Palmer",
      "tracks": []
    },
    "5439": {
      "album": "ABBA Gold"
    }
};

var collectionCopy = JSON.parse(JSON.stringify(collection));         <- make copy of object.

function updateRecords(id, prop, value) {
  if (value === "") {
    delete collection[id][prop];
  } else if (prop === "tracks") {
    collection[id][prop] = collection[id][prop] || [];               <- collection id prop exist, we will set it as is but if not will be blank
    collection[id][prop].push(value);
  } else  {
    collection[id][prop] = value;
  }
  return collection;
}

console.log(updateRecords(5439, "artist", "ABBA"));       <- 5439: {album:"ABBA Bold", artist:"ABBA"}

# Iterate with While Loop
